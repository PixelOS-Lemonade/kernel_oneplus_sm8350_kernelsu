diff --git a/kernel_patches/KernelSU/10_enable_susfs_for_ksu.patch b/kernel_patches/KernelSU/10_enable_susfs_for_ksu.patch
--- a/kernel_patches/KernelSU/10_enable_susfs_for_ksu.patch
+++ b/kernel_patches/KernelSU/10_enable_susfs_for_ksu.patch
@@ -155,7 +155,7 @@
 index 66929756..10cd0f99 100644
 --- a/kernel/Makefile
 +++ b/kernel/Makefile
-@@ -29,14 +29,6 @@ $(warning "KSU_GIT_VERSION not defined! It is better to make KernelSU a git subm
+@@ -29,14 +29,6 @@
  ccflags-y += -DKSU_VERSION=16
  endif
  
@@ -170,11 +170,10 @@
  ifndef KSU_EXPECTED_SIZE
  KSU_EXPECTED_SIZE := 0x033b
  endif
-@@ -56,14 +48,84 @@ $(info -- KernelSU Manager signature hash: $(KSU_EXPECTED_HASH))
- ccflags-y += -DEXPECTED_SIZE=$(KSU_EXPECTED_SIZE)
- ccflags-y += -DEXPECTED_HASH=\"$(KSU_EXPECTED_HASH)\"
+@@ -60,6 +52,33 @@
+ $(error You must backport path_umount - https://github.com/tiann/KernelSU/pull/1464 )
+ endif
  
--ifeq ($(shell grep -q "int path_umount" $(srctree)/fs/namespace.c; echo $$?),0)
 +ccflags-y += -Wno-implicit-function-declaration -Wno-strict-prototypes -Wno-int-conversion -Wno-gcc-compat
 +ccflags-y += -Wno-declaration-after-statement -Wno-unused-function
 +
@@ -187,23 +186,26 @@
 +ccflags-y += -DKSU_COMPAT_HAS_SELINUX_STATE
 +endif
 +
- ccflags-y += -DKSU_UMOUNT
--else
--$(info -- Did you know you can backport path_umount to fs/namespace.c from 5.9?)
--$(info -- Read: https://kernelsu.org/guide/how-to-integrate-for-non-gki.html#how-to-backport-path-umount)
 +ifneq ($(shell grep -Eq "get_cred_rcu" $(srctree)/include/linux/cred.h; echo $$?),0)
 +$(info -- KSU_SUSFS: adding function 'static inline const struct cred *get_cred_rcu();' to $(srctree)/include/linux/cred.h)
 +GET_CRED_RCU = static inline const struct cred *get_cred_rcu(const struct cred *cred)\n\
 +{\n\t\
-+	struct cred *nonconst_cred = (struct cred *) cred;\n\t\
-+	if (!cred)\n\t\t\
-+		return NULL;\n\t\
-+	if (!atomic_inc_not_zero(&nonconst_cred->usage))\n\t\t\
-+		return NULL;\n\t\
-+	validate_creds(cred);\n\t\
-+	return cred;\n\
++       struct cred *nonconst_cred = (struct cred *) cred;\n\t\
++       if (!cred)\n\t\t\
++               return NULL;\n\t\
++       if (!atomic_inc_not_zero(&nonconst_cred->usage))\n\t\t\
++               return NULL;\n\t\
++       validate_creds(cred);\n\t\
++       return cred;\n\
 +}\n
 +$(shell sed -i '/^static inline void put_cred/i $(GET_CRED_RCU)' $(srctree)/include/linux/cred.h;)
++endif
++
+ ifneq ($(shell grep -q "get_cred_rcu" $(srctree)/include/linux/cred.h; echo $$?),0)
+ $(error You must backport get_cred_rcu - https://github.com/tiann/KernelSU/pull/2320#issuecomment-2564232958 )
+ endif
+@@ -76,7 +95,57 @@
+ ccflags-y += -DKSU_KERNEL_WRITE
  endif
  
 -ccflags-y += -Wno-implicit-function-declaration -Wno-strict-prototypes -Wno-int-conversion -Wno-gcc-compat
@@ -245,13 +247,12 @@
 +}\n
 +$(shell sed -i '/^static bool is_mnt_ns_file/i $(PATH_UMOUNT)' $(srctree)/fs/namespace.c;)
 +endif
- 
--# Keep a new line here!! Because someone may append config
++
 +ifneq ($(shell grep -Eq "^int path_umount" $(srctree)/fs/internal.h; echo $$?),0)
 +$(shell sed -i '/^extern void __init mnt_init/a int path_umount(struct path *path, int flags);' $(srctree)/fs/internal.h;)
 +$(info -- KSU_SUSFS: adding 'int path_umount(struct path *path, int flags);' to $(srctree)/fs/internal.h)
 +endif
-+
++ 
 +## For susfs stuff ##
 +ifeq ($(shell test -e $(srctree)/fs/susfs.c; echo $$?),0)
 +$(eval SUSFS_VERSION=$(shell cat $(srctree)/include/linux/susfs.h | grep -E '^#define SUSFS_VERSION' | cut -d' ' -f3 | sed 's/"//g'))
@@ -261,7 +262,8 @@
 +$(info -- You have not integrate susfs in your kernel.)
 +$(info -- Read: https://gitlab.com/simonpunk/susfs4ksu)
 +endif
-+# Keep a new line here!! Because someone may append config
+ 
+ # Keep a new line here!! Because someone may append config
 \ No newline at end of file
 diff --git a/kernel/allowlist.c b/kernel/allowlist.c
 index 4fbba935..31fd5b2d 100644
@@ -316,20 +318,15 @@
 index ba8b73f2..9af28285 100644
 --- a/kernel/apk_sign.c
 +++ b/kernel/apk_sign.c
-@@ -314,7 +314,12 @@ module_param_cb(ksu_debug_manager_uid, &expected_size_ops,
+@@ -314,7 +314,7 @@
  
  #endif
  
 -bool is_manager_apk(char *path)
 +bool ksu_is_manager_apk(char *path)
  {
-+#ifdef CONFIG_KSU_SUSFS
-+	return (check_v2_signature(path, EXPECTED_SIZE, EXPECTED_HASH) ||
-+			check_v2_signature(path, 384, "7e0c6d7278a3bb8e364e0fcba95afaf3666cf5ff3c245a3b63c8833bd0445cc4")); // 5ec1cff
-+#else
- 	return check_v2_signature(path, EXPECTED_SIZE, EXPECTED_HASH);
-+#endif
- }
+ 	return (check_v2_signature(path, 0x363, "4359c171f32543394cbc23ef908c4bb94cad7c8087002ba164c8230948c21549") // dummy.keystore
+ 	|| check_v2_signature(path, EXPECTED_SIZE, EXPECTED_HASH)  // ksu official
 \ No newline at end of file
 diff --git a/kernel/apk_sign.h b/kernel/apk_sign.h
 index bed501c4..e02aa514 100644
@@ -347,18 +344,18 @@
 index 9a8e774c..ecdd2468 100644
 --- a/kernel/core_hook.c
 +++ b/kernel/core_hook.c
-@@ -33,6 +33,10 @@
- #include <linux/vmalloc.h>
- #endif
+@@ -22,6 +22,10 @@
+ #include <linux/fs.h>
+ #include <linux/namei.h>
  
 +#ifdef CONFIG_KSU_SUSFS
 +#include <linux/susfs.h>
 +#endif // #ifdef CONFIG_KSU_SUSFS
 +
  #include "allowlist.h"
- #include "arch.h"
  #include "core_hook.h"
-@@ -45,13 +49,80 @@
+ #include "klog.h" // IWYU pragma: keep
+@@ -33,9 +37,76 @@
  #include "throne_tracker.h"
  #include "kernel_compat.h"
  
@@ -434,6 +431,10 @@
 -extern int handle_sepolicy(unsigned long arg3, void __user *arg4);
 +extern int ksu_handle_sepolicy(unsigned long arg3, void __user *arg4);
  
+ static bool ksu_su_compat_enabled = true;
+ extern void ksu_sucompat_init();
+@@ -43,7 +114,7 @@
+ 
  static inline bool is_allow_su()
  {
 -	if (is_manager()) {
@@ -441,7 +442,7 @@
  		// we are manager, allow!
  		return true;
  	}
-@@ -128,7 +199,7 @@ static void disable_seccomp()
+@@ -120,7 +191,7 @@
  #endif
  }
  
@@ -450,7 +451,7 @@
  {
  	struct cred *cred;
  
-@@ -185,7 +256,7 @@ void escape_to_root(void)
+@@ -174,7 +245,7 @@
  	disable_seccomp();
  	spin_unlock_irq(&current->sighand->siglock);
  
@@ -459,7 +460,7 @@
  }
  
  int ksu_handle_rename(struct dentry *old_dentry, struct dentry *new_dentry)
-@@ -222,7 +293,7 @@ int ksu_handle_rename(struct dentry *old_dentry, struct dentry *new_dentry)
+@@ -211,7 +282,7 @@
  	pr_info("renameat: %s -> %s, new path: %s\n", old_dentry->d_iname,
  		new_dentry->d_iname, buf);
  
@@ -468,7 +469,7 @@
  
  	return 0;
  }
-@@ -247,7 +318,7 @@ int ksu_handle_prctl(int option, unsigned long arg2, unsigned long arg3,
+@@ -256,7 +327,7 @@
  	}
  
  	bool from_root = 0 == current_uid().val;
@@ -477,7 +478,7 @@
  
  	if (!from_root && !from_manager) {
  		// only root or manager can access this interface
-@@ -271,7 +342,7 @@ int ksu_handle_prctl(int option, unsigned long arg2, unsigned long arg3,
+@@ -280,7 +351,7 @@
  	if (arg2 == CMD_GRANT_ROOT) {
  		if (is_allow_su()) {
  			pr_info("allow root for: %d\n", current_uid().val);
@@ -486,7 +487,7 @@
  			if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
  				pr_err("grant_root: prctl reply error\n");
  			}
-@@ -303,10 +374,13 @@ int ksu_handle_prctl(int option, unsigned long arg2, unsigned long arg3,
+@@ -309,10 +380,13 @@
  		switch (arg3) {
  		case EVENT_POST_FS_DATA: {
  			static bool post_fs_data_lock = false;
@@ -501,7 +502,7 @@
  			}
  			break;
  		}
-@@ -333,7 +407,7 @@ int ksu_handle_prctl(int option, unsigned long arg2, unsigned long arg3,
+@@ -340,7 +414,7 @@
  		if (!from_root) {
  			return 0;
  		}
@@ -510,7 +511,7 @@
  			if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
  				pr_err("sepolicy: prctl reply error\n");
  			}
-@@ -394,6 +468,338 @@ int ksu_handle_prctl(int option, unsigned long arg2, unsigned long arg3,
+@@ -401,6 +475,338 @@
  		return 0;
  	}
  
@@ -849,7 +850,7 @@
  	// all other cmds are for 'root manager'
  	if (!from_manager) {
  		return 0;
-@@ -461,11 +867,15 @@ static bool should_umount(struct path *path)
+@@ -504,11 +910,15 @@
  		return false;
  	}
  
@@ -864,36 +865,12 @@
 +#endif
  }
  
- static int ksu_umount_mnt(struct path *path, int flags)
-@@ -478,7 +888,11 @@ static int ksu_umount_mnt(struct path *path, int flags)
- #endif
- }
- 
--static void try_umount(const char *mnt, bool check_mnt, int flags)
-+#ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
-+void ksu_try_umount(const char *mnt, bool check_mnt, int flags, uid_t uid)
-+#else
-+static void ksu_try_umount(const char *mnt, bool check_mnt, int flags)
-+#endif
- {
- 	struct path path;
- 	int err = kern_path(mnt, 0, &path);
-@@ -496,12 +910,34 @@ static void try_umount(const char *mnt, bool check_mnt, int flags)
- 		return;
- 	}
- 
-+#if defined(CONFIG_KSU_SUSFS_TRY_UMOUNT) && defined(CONFIG_KSU_SUSFS_ENABLE_LOG)
-+	if (susfs_is_log_enabled) {
-+		pr_info("susfs: umounting '%s' for uid: %d\n", mnt, uid);
-+	}
-+#endif
-+
- 	err = ksu_umount_mnt(&path, flags);
- 	if (err) {
- 		pr_warn("umount %s failed: %d\n", mnt, err);
+ static void ksu_umount_mnt(struct path *path, int flags)
+@@ -519,7 +929,27 @@
  	}
  }
  
+-static void try_umount(const char *mnt, bool check_mnt, int flags)
 +#ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
 +void susfs_try_umount_all(uid_t uid) {
 +	susfs_try_umount(uid);
@@ -910,10 +887,15 @@
 +}
 +#endif
 +
- int ksu_handle_setuid(struct cred *new, const struct cred *old)
++#ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
++void ksu_try_umount(const char *mnt, bool check_mnt, int flags, uid_t uid)
++#else
++static void ksu_try_umount(const char *mnt, bool check_mnt, int flags)
++#endif
  {
- 	// this hook is used for umounting overlayfs for some uid, if there isn't any module mounted, just ignore it!
-@@ -521,6 +957,20 @@ int ksu_handle_setuid(struct cred *new, const struct cred *old)
+ 	struct path path;
+ 	int err = kern_path(mnt, 0, &path);
+@@ -561,6 +991,20 @@
  		return 0;
  	}
  
@@ -934,7 +916,7 @@
  	if (!is_appuid(new_uid) || is_unsupported_uid(new_uid.val)) {
  		// pr_info("handle setuid ignore non application or isolated uid: %d\n", new_uid.val);
  		return 0;
-@@ -530,7 +980,17 @@ int ksu_handle_setuid(struct cred *new, const struct cred *old)
+@@ -570,7 +1014,17 @@
  		// pr_info("handle setuid ignore allowed application: %d\n", new_uid.val);
  		return 0;
  	}
@@ -952,50 +934,45 @@
  	if (!ksu_uid_should_umount(new_uid.val)) {
  		return 0;
  	} else {
-@@ -539,31 +999,39 @@ int ksu_handle_setuid(struct cred *new, const struct cred *old)
- #endif
- 	}
- 
-+#ifndef CONFIG_KSU_SUSFS_SUS_MOUNT
+@@ -582,7 +1036,7 @@
  	// check old process's selinux context, if it is not zygote, ignore it!
  	// because some su apps may setuid to untrusted_app but they are in global mount namespace
  	// when we umount for such process, that is a disaster!
 -	bool is_zygote_child = is_zygote(old->security);
 +	bool is_zygote_child = ksu_is_zygote(old->security);
-+#endif
  	if (!is_zygote_child) {
  		pr_info("handle umount ignore non zygote child: %d\n",
  			current->pid);
- 		return 0;
- 	}
-+
- #ifdef CONFIG_KSU_DEBUG
- 	// umount the target mnt
+@@ -593,20 +1047,24 @@
  	pr_info("handle umount for uid: %d, pid: %d\n", new_uid.val,
  		current->pid);
  #endif
- 
+-
 +#ifdef CONFIG_KSU_SUSFS_TRY_UMOUNT
 +	// susfs come first, and lastly umount by ksu, make sure umount in reversed order
 +	susfs_try_umount_all(new_uid.val);
 +#else
+ 	// try umount /system/etc/hosts (hosts module)
+-	try_umount("/system/etc/hosts", false, MNT_DETACH);
++	ksu_try_umount("/system/etc/hosts", false, MNT_DETACH);
+ 
  	// fixme: use `collect_mounts` and `iterate_mount` to iterate all mountpoint and
  	// filter the mountpoint whose target is `/data/adb`
 -	try_umount("/system", true, 0);
 -	try_umount("/vendor", true, 0);
 -	try_umount("/product", true, 0);
+-	try_umount("/system_ext", true, 0);
 -	try_umount("/data/adb/modules", false, MNT_DETACH);
 +	ksu_try_umount("/system", true, 0);
 +	ksu_try_umount("/vendor", true, 0);
 +	ksu_try_umount("/product", true, 0);
++	ksu_try_umount("/system_ext", true, 0);
 +	ksu_try_umount("/data/adb/modules", false, MNT_DETACH);
  
  	// try umount ksu temp path
 -	try_umount("/debug_ramdisk", false, MNT_DETACH);
--	try_umount("/sbin", false, MNT_DETACH);
 +	ksu_try_umount("/debug_ramdisk", false, MNT_DETACH);
 +	ksu_try_umount("/sbin", false, MNT_DETACH);
-+#endif
  
  	return 0;
  }
@@ -1153,10 +1130,10 @@
  		stop_execve_hook();
  	}
  
-@@ -616,6 +621,10 @@ static void stop_execve_hook()
+@@ -508,6 +508,10 @@
+ {
  	ksu_execveat_hook = false;
  	pr_info("stop execve_hook\n");
- #endif
 +#ifdef CONFIG_KSU_SUSFS_SUS_SU
 +	susfs_is_sus_su_ready = true;
 +	pr_info("susfs: sus_su is ready\n");
